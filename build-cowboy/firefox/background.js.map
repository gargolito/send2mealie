{"version":3,"file":"background.js","mappings":"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","sources":["webpack://send2mealie/./src/cowboy/browser-polyfill.js","webpack://send2mealie/./src/cowboy/background.js"],"sourcesContent":["/**\n * Browser API compatibility layer for Chrome MV3 and Firefox MV2\n * Provides unified API that works across both browsers\n */\n\n// Detect browser environment\nconst isFirefox = typeof browser !== 'undefined' && browser.runtime?.id;\n\n// Use browser namespace if available (Firefox), otherwise chrome\nconst browserAPI = typeof browser !== 'undefined' ? browser : chrome;\n\n/**\n * Unified action/browserAction API\n * Chrome MV3 uses 'action', Firefox MV2 uses 'browserAction'\n */\nconst actionAPI = browserAPI.action || browserAPI.browserAction;\n\n/**\n * Execute script in a tab\n * Chrome MV3: chrome.scripting.executeScript({ target: { tabId }, files: [...] })\n * Firefox MV2: browser.tabs.executeScript(tabId, { file: ... })\n */\nasync function executeScript(tabId, files) {\n  if (browserAPI.scripting?.executeScript) {\n    // Chrome MV3\n    return browserAPI.scripting.executeScript({\n      target: { tabId },\n      files: files\n    });\n  } else {\n    // Firefox MV2 - execute each file sequentially\n    for (const file of files) {\n      await browserAPI.tabs.executeScript(tabId, { file });\n    }\n  }\n}\n\n/**\n * Open the extension popup\n * Note: Firefox doesn't support programmatically opening the popup\n * This is a no-op on Firefox\n */\nfunction openPopup() {\n  if (actionAPI?.openPopup) {\n    try {\n      actionAPI.openPopup();\n    } catch (e) {\n      // Firefox doesn't support this - silent fail\n      console.log('Send2Mealie: Popup cannot be opened programmatically');\n    }\n  }\n}\n\nexport {\n  browserAPI,\n  actionAPI,\n  isFirefox,\n  executeScript,\n  openPopup\n};\n","// \"Operates only on user-approved sites and transmits only page URLs required for recipe detection and import.\"\n// This script does not scrape page content or transmit browsing data.\n\nimport { executeScript, openPopup } from './browser-polyfill.js';\n\n// Use browser namespace (Firefox) if available, otherwise chrome\nconst api = typeof browser !== 'undefined' ? browser : chrome;\nconst isFirefox = typeof browser !== 'undefined';\nconst actionAPI = api.action || api.browserAction;\nconst permissionWarningState = new Map();\n\nfunction flagPermissionWarning(tabId, domain) {\n  if (!actionAPI?.setBadgeText) return;\n  const current = permissionWarningState.get(tabId);\n  if (current === domain) return;\n  permissionWarningState.set(tabId, domain);\n  actionAPI.setBadgeBackgroundColor?.({ color: '#d93025', tabId });\n  actionAPI.setBadgeText({ text: '!', tabId });\n  actionAPI.setTitle?.({\n    tabId,\n    title: `Grant Send2Mealie permission for ${domain} via the popup`\n  });\n}\n\nfunction clearPermissionWarning(tabId) {\n  if (!actionAPI?.setBadgeText) return;\n  if (!permissionWarningState.has(tabId)) return;\n  permissionWarningState.delete(tabId);\n  actionAPI.setBadgeText({ text: '', tabId });\n  actionAPI.setTitle?.({ tabId, title: 'Send to Mealie' });\n}\n\nasync function isRecipePage(url, mealieUrl, mealieApiToken) {\n  try {\n    const endpoint = new URL('/api/recipes/test-scrape-url', mealieUrl);\n\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), 5000);\n    // Determines whether the current page URL can be scraped as a recipe by Mealie.\n    // This request sends only the page URL for compatibility checking.\n    // No page content, user data, or browsing history is transmitted.\n    const resp = await fetch(endpoint.href, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${mealieApiToken}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ url }),\n      signal: controller.signal\n    });\n\n    clearTimeout(timeout);\n\n    if (!resp.ok) return false;\n\n    const contentLength = parseInt(resp.headers.get('content-length') || '0', 10);\n    return contentLength > 500;\n  } catch (e) {\n    return false;\n  }\n}\n\napi.runtime.onInstalled.addListener(() => {\n  // no-op\n});\n\n// Injects the content script only after page load completes,\n// and only on user-approved sites.\n// This is required to detect recipe pages and render the \"Send to Mealie\" UI.\n// No browsing data is collected or transmitted during this step.\napi.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {\n  if (changeInfo.status !== 'complete') return;\n\n  try {\n    if (!tab.url) return;\n\n    const result = await api.storage.sync.get({ userSites: [] }) || {};\n    const userSites = result.userSites || [];\n    if (userSites.length === 0) {\n      clearPermissionWarning(tabId);\n      return;\n    }\n\n    const tabUrl = new URL(tab.url);\n    const tabDomain = tabUrl.hostname.replace(/^www\\./, '');\n\n    // Check if current domain matches any user site\n    const matchedDomain = userSites.find(domain => tabDomain.endsWith(domain));\n    if (matchedDomain) {\n      // Try to inject the script - will fail silently if no permission\n      try {\n        await executeScript(tabId, ['contentScript.js']);\n        clearPermissionWarning(tabId);\n      } catch (injectionError) {\n        const message = injectionError?.message || '';\n        if (/Missing host permission|Cannot access contents of the page/i.test(message)) {\n          console.warn('Send2Mealie: Missing host permission for tab', tabId, matchedDomain);\n          flagPermissionWarning(tabId, matchedDomain);\n        } else {\n          console.error('Send2Mealie: Error injecting content script', injectionError);\n        }\n      }\n    } else {\n      clearPermissionWarning(tabId);\n    }\n  } catch (e) {\n    console.error('Send2Mealie: Error in tabs.onUpdated listener', e);\n  }\n});\n\n// Handle action/browserAction click - use appropriate API based on browser\nif (actionAPI?.onClicked) {\n  actionAPI.onClicked.addListener((tab) => {\n    api.storage.sync.get([\"mealieUrl\", \"mealieApiToken\"]).then((cfg) => {\n      if (!cfg.mealieUrl || !cfg.mealieApiToken) {\n        openPopup();\n        return;\n      }\n      createRecipeViaApi(tab.url, cfg.mealieUrl, cfg.mealieApiToken);\n    });\n  });\n}\n\n// Checks whether a recipe URL already exists in the user's Mealie instance.\n// Only the page URL is transmitted; no page content is accessed or sent.\nasync function checkDuplicate(url, mealieUrl, mealieApiToken) {\n  try {\n    const endpoint = new URL('/api/recipes', mealieUrl);\n\n    const sanitizedUrl = JSON.stringify(url || '');\n    endpoint.search = new URLSearchParams({\n      page: 1,\n      perPage: 1,\n      queryFilter: `orgURL = ${sanitizedUrl}`\n    }).toString();\n\n    const resp = await fetch(endpoint.href, {\n      method: 'GET',\n      headers: {\n        'Authorization': `Bearer ${mealieApiToken}`,\n        'Accept': 'application/json'\n      }\n    });\n\n    if (!resp.ok) return null;\n\n    const data = await resp.json();\n\n    return data?.items?.length > 0 ? data.items[0] : null;\n  } catch (e) {\n    return null;\n  }\n}\n\nasync function createRecipeViaApi(url, mealieUrl, mealieApiToken) {\n  try {\n    const fetchUrl = new URL('/api/recipes/create/url', mealieUrl).href;\n    const resp = await fetch(fetchUrl, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${mealieApiToken}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ url })\n    });\n    if (!resp.ok) throw new Error('Failed to send recipe');\n    await resp.json();\n    // Displays a confirmation notification after an explicit user action.\n    // Notifications are not used for advertising or background alerts.\n    api.notifications?.create({ type: \"basic\", title: \"Sent to Mealie\", iconUrl: \"icon-128.png\", message: \"Recipe URL submitted.\" });\n  } catch (e) {\n    api.notifications?.create({ type: \"basic\", title: \"Mealie error\", iconUrl: \"icon-128.png\", message: \"Failed to send recipe\" });\n  }\n}\n\n// Handles messages from content scripts related to recipe detection,\n// duplicate checking, and explicit user-initiated imports.\n// No background processing occurs outside these scoped requests.\napi.runtime.onMessage.addListener((msg, sender, sendResponse) => {\n  // Imports a recipe into Mealie only after explicit user action.\n  // This operation is not performed automatically.\n  if (msg?.type === \"createViaApi\" && msg.url) {\n    (async () => {\n      const cfg = await api.storage.sync.get([\"mealieUrl\", \"mealieApiToken\", \"enableDuplicateCheck\"]);\n      const { mealieUrl, mealieApiToken, enableDuplicateCheck } = cfg;\n      if (!mealieUrl || !mealieApiToken) { openPopup(); sendResponse({ success: false }); return; }\n      try {\n        if (enableDuplicateCheck) {\n          const existing = await checkDuplicate(msg.url, mealieUrl, mealieApiToken);\n          if (existing) {\n            sendResponse({ success: false, error: \"Recipe already imported\", duplicate: true, recipe: existing });\n            return;\n          }\n        }\n        const fetchUrl = new URL('/api/recipes/create/url', mealieUrl).href;\n        const resp = await fetch(fetchUrl, {\n          method: 'POST',\n          headers: {\n            'Authorization': `Bearer ${mealieApiToken}`,\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({ url: msg.url })\n        });\n        if (!resp.ok) throw new Error(`HTTP error! status: ${resp.status}`);\n        await resp.json();\n        sendResponse({ success: true });\n      } catch (e) {\n        sendResponse({ success: false, error: \"Failed to send recipe\" });\n      }\n    })();\n    return true;\n  }\n\n  if (msg?.type === \"checkDuplicate\" && msg.url) {\n    (async () => {\n      const cfg = await api.storage.sync.get([\"mealieUrl\", \"mealieApiToken\"]);\n      const { mealieUrl, mealieApiToken } = cfg;\n      if (!mealieUrl || !mealieApiToken) {\n        sendResponse({ exists: false });\n        return;\n      }\n      try {\n        const recipe = await checkDuplicate(msg.url, mealieUrl, mealieApiToken);\n        sendResponse({ exists: !!recipe });\n      } catch (e) {\n        sendResponse({ exists: false });\n      }\n    })();\n    return true;\n  }\n\n  if (msg?.type === \"isRecipePage\" && msg.url) {\n    (async () => {\n      const cfg = await api.storage.sync.get([\"mealieUrl\", \"mealieApiToken\"]);\n      const { mealieUrl, mealieApiToken } = cfg;\n      if (!mealieUrl || !mealieApiToken) {\n        sendResponse({ isRecipe: false });\n        return;\n      }\n      try {\n        const isRecipe = await isRecipePage(msg.url, mealieUrl, mealieApiToken);\n        sendResponse({ isRecipe });\n      } catch (e) {\n        sendResponse({ isRecipe: false });\n      }\n    })();\n    return true;\n  }\n});\n"],"names":["browser","runtime","browserAPI","chrome","actionAPI","action","browserAction","openPopup","e","console","log","api","permissionWarningState","Map","clearPermissionWarning","tabId","setBadgeText","has","delete","text","setTitle","title","async","checkDuplicate","url","mealieUrl","mealieApiToken","endpoint","URL","sanitizedUrl","JSON","stringify","search","URLSearchParams","page","perPage","queryFilter","toString","resp","fetch","href","method","headers","ok","data","json","items","length","onInstalled","addListener","tabs","onUpdated","changeInfo","tab","status","userSites","storage","sync","get","tabDomain","hostname","replace","matchedDomain","find","domain","endsWith","files","scripting","executeScript","target","file","injectionError","test","message","warn","set","setBadgeBackgroundColor","color","flagPermissionWarning","error","onClicked","then","cfg","fetchUrl","body","Error","notifications","create","type","iconUrl","createRecipeViaApi","onMessage","msg","sender","sendResponse","enableDuplicateCheck","success","existing","duplicate","recipe","exists","isRecipe","controller","AbortController","timeout","setTimeout","abort","signal","clearTimeout","parseInt","isRecipePage"],"ignoreList":[],"sourceRoot":""}